rdb-fullstack
=============

Common code for the Relational Databases and Full Stack Fundamentals courses

# Swiss Pairings Engine
A Python module for tournament management using [Swiss-system tournament management][1].
[1]:https://en.wikipedia.org/wiki/Swiss-system_tournament
The engine runs inside of a VirtualBox guest setup with Vagrant.


## Install and Setup

Meet these dependencies first on your host machine:
- [Vagrant 1.7.4][2]
- [VirtualBox 5.0][3]
[2]:https://www.vagrantup.com/
[3]:https://www.virtualbox.org/

1. Clone this repo and cd into the local repo directory.
  * `git clone https://github.com/justinvhester/vm-fullstack-nanodegree`
  * `cd vm-fullstack-nanodegree`
2. Start the virtual machine using Vagrant.
  * `vagrantup`
3. Connect to a terminal session on the virtual machine using Vagrant.
  * `vagrant ssh`
4. Change into the shared vagrant/tournament directory.
  * `cd /vagrant/tournament`
    * This directory contains the code for the tournament engine.
5. Connect to the database and run the tournament.sql file to setup the database.
  * `psql`
    * NOTE: this will change the prompt from bash to `vagrant=>`
  * `\i tournament.sql`

At this point the database and virtual machine is ready for use.
NOTE: Use `\q` to disconnect from the psql prompt.

## Usage

Functions defined in tournament.py can be called from a python prompt.
Once you're connected using `vagrant ssh` and inside the /vagrant/tournament directory the following example demonstrates some of the functions.

```python
>>> from tournament import *
>>> countPlayers()
0L
>>> registerPlayer('Alice')
>>> registerPlayer('Bob')
>>> registerPlayer('Cathy')
>>> registerPlayer("Danny O'Hare")
>>> countPlayers()
4L
```

Once all participants are registered swissPairings() will give you a list of pairs for round one.
```python
>>> swissPairings()
[(398, 'Alice', 399, 'Bob'), (400, 'Cathy', 401, "Danny O'Hare")]
```
After the first round is over, report the results to the database with reportMatch().
This function takes two arguments; the first is the player id of the winner,
the second is the player id of the loser for that round.

Assuming Alice and Cathy won their first round games:
```python
>>> reportMatch(398, 399)
>>> reportMatch(400, 401)
```

You can then get the current standings of all registered players with playerStandings().
```python
>>>playerStandings()
[(398, 'Alice', 1L, 1L), (400, 'Cathy', 1L, 1L), (399, 'Bob', 0L, 1L), (401, "Danny O'Hare", 0L, 1L)]
```

## Known issues
### Rematches
Currently there is no restriction on rematches in the pairing algorithm.
The pairs are generated by going through the list of players ordered by number of wins.
So after two rounds of play, players with two wins will appear at the top of this list.
The `swissPairings()` function will simply pull the "next two" players off the top of the list.
In testing the function a rematch rarely happened in 4 and 8 player tournaments.
With 16 players or more a rematch would eventually occur due to the simplicity of the algorithm.
Some work has been accomplished to update the swissPairings() function to avoid a rematch pair.
Namely a compound key in the matches table and a new VIEW in `tournament.sql` that will provide a list of possible matches to check when generating the pairs. See the no-rematch feature branch for more details.

##Road Map
I would like to implement the following in no particular order.
* Prevent rematches
  * See no-rematch branch for current progress
* Give a 'bye' to the one left over player when there is an odd number of players
  * Prevent a single player from receiving more than one bye per tournament
* Break ties by calculating the strength of opponents defeated previously
  * Having beaten someone with more wins than your opponent should git you the edge
* Deal with drawn matches
* Deal with multiple games per match
* Generate Chess 960 starting positions
* Begin the work for a pybottle front end
  * Package it all up to run stand-alone on a system that meets the dependency requirements

